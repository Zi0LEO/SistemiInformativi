package com.opcal;

import java.sql.Connection;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Set;
import java.util.HashSet;
import java.util.stream.Collectors;

import org.apache.torque.NoRowsException;
import org.apache.torque.TooManyRowsException;
import org.apache.torque.TorqueException;
import org.apache.torque.criteria.Criteria;
import org.apache.torque.criteria.Criterion;
import org.apache.torque.om.mapper.RecordMapper;
import org.apache.torque.om.mapper.CompositeMapper;
import org.apache.torque.om.ObjectKey;
import org.apache.torque.om.SimpleKey;
import org.apache.torque.map.TableMap;
import org.apache.torque.util.TorqueConnection;
import org.apache.torque.util.Transaction;
import org.apache.torque.util.ColumnValues;
import org.apache.torque.util.JdbcTypedValue;



/**
 * The skeleton for this class was autogenerated by Torque on:
 *
 * [Thu Mar 13 14:45:22 CET 2025]
 *
 * You should not use this class directly.  It should not even be
 * extended; all references should be to SpedizionePeer
 */

@SuppressWarnings("unused")
public abstract class BaseSpedizionePeerImpl
    extends org.apache.torque.util.AbstractPeerImpl<Spedizione>
{
    /** Serial version */
    private static final long serialVersionUID = 1741873522826L;



    /**
     * Constructor.
     * The recordMapper, tableMap and databaseName fields are correctly
     * initialized.
     */
    public BaseSpedizionePeerImpl()
    {
        this(new SpedizioneRecordMapper(),
            SpedizionePeer.TABLE,
            SpedizionePeer.DATABASE_NAME);
    }

    /**
     * Constructor providing the objects to be injected as parameters.
     *
     * @param recordMapper a record mapper to map JDBC result sets to objects
     * @param tableMap the default table map
     * @param databaseName the name of the database
     */
    public BaseSpedizionePeerImpl(
            RecordMapper<Spedizione> recordMapper, 
            TableMap tableMap,
            String databaseName)
    {
        super(recordMapper, tableMap, databaseName);
    }


    /**
     * Returns a new instance of the Data object class
     */
    public Spedizione getDbObjectInstance()
    {
        return new Spedizione();
    }


    /**
     * Method to do updates.  This method is to be used during a transaction,
     * otherwise use the doUpdate(Criteria) method.
     *
     * @param columnValues the values to update plus the primary key
     *        identifying the row to update.
     * @param con the connection to use, not null.
     *
     * @return the number of affected rows.
     *
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     */
    public int doUpdate(ColumnValues columnValues, Connection con)
        throws TorqueException
    {
        Criteria selectCriteria = new Criteria(getDatabaseName());
        correctBooleans(columnValues);

        {
            JdbcTypedValue pkValue
                = columnValues.remove(SpedizionePeer.CODICE);
            if (pkValue == null)
            {
                throw new TorqueException(
                        "The value for the primary key column "
                        + "SpedizionePeer.CODICE"
                        + " must be set");
            }
            if (pkValue.getSqlExpression() == null)
            {
                selectCriteria.where(
                        SpedizionePeer.CODICE,
                        pkValue.getValue());
            }
            else
            {
                selectCriteria.where(
                        SpedizionePeer.CODICE,
                        pkValue.getSqlExpression());
            }
        }


        int rowCount = doUpdate(selectCriteria, columnValues, con);
        return rowCount;
    }

    /**
     * Deletes a data object, i.e. a row in a table, in the database.
     *
     * @param obj the data object to delete in the database, not null.
     *
     * @return the number of deleted rows.
     *
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     */
    public int doDelete(Spedizione obj) throws TorqueException
    {
        int result = doDelete(buildCriteria(obj.getPrimaryKey()));
        obj.setDeleted(true);
        return result;
    }

    /**
     * Deletes a data object, i.e. a row in a table, in the database.
     * This method is to be used during a transaction, otherwise use the
     * doDelete(Spedizione) method.
     *
     * @param obj the data object to delete in the database, not null.
     * @param con the connection to use, not null.
     *
     * @return the number of deleted rows.
     *
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     */
    public int doDelete(Spedizione obj, Connection con)
        throws TorqueException
    {
        int result = doDelete(buildCriteria(obj.getPrimaryKey()), con);
        obj.setDeleted(true);
        return result;
    }

    /**
     * Deletes data objects, i.e. rows in a table, in the database.
     *
     * @param objects the data object to delete in the database, not null,
     *        may not contain null.
     *
     * @return the number of deleted rows.
     *
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     */
    public int doDelete(Collection<Spedizione> objects)
            throws TorqueException
    {
        int result = doDelete(buildPkCriteria(objects));
        objects.forEach(object -> object.setDeleted(true));
        return result;
    }

    /**
     * Deletes data objects, i.e. rows in a table, in the database.
     * This method uses the passed connection to delete the rows;
     * if a transaction is open in the connection, the deletion happens inside
     * this transaction.
     *
     * @param objects the data objects to delete in the database, not null,
     *        may not contain null.
     * @param con the connection to use for deleting, not null.
     *
     * @return the number of deleted rows.
     *
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     */
    public int doDelete(
            Collection<Spedizione> objects,
            Connection con)
        throws TorqueException
    {
        int result = doDelete(buildPkCriteria(objects), con);
        objects.forEach(object -> object.setDeleted(true));
        return result;
    }

    /** 
     * Build a Criteria object which selects all objects which have a given
     * primary key.
     *
     * @param pk the primary key value to build the criteria from, not null.
     */
    public Criteria buildCriteria(ObjectKey<?> pk)
    {
        Criteria criteria = new Criteria();
        criteria.and(SpedizionePeer.CODICE, pk);
        return criteria;
     }

    /** 
     * Build a Criteria object which selects all objects which primary keys
     * are contained in the passed collection.
     *
     * @param pks the primary key values to build the criteria from, not null,
     *        may not contain null.
     */
    public Criteria buildCriteria(Collection<ObjectKey<?>> pks)
    {
        Criteria criteria = new Criteria();
        criteria.andIn(SpedizionePeer.CODICE, pks);
        return criteria;
     }


    /** 
     * Build a Criteria object which selects all passed objects using their
     * primary key. Objects which do not yet have a primary key are ignored.
     *
     * @param objects the objects to build the criteria from, not null,
     *        may not contain null.
     */
    public Criteria buildPkCriteria(
            Collection<Spedizione> objects)
    {
        return buildCriteria(objects.stream()
                .map(object -> object.getPrimaryKey())
                .collect(Collectors.toList()));
    }

    /** 
     * Build a Criteria object from the data object for this peer.
     * The primary key columns are only added if the object is not new.
     *
     * @param obj the object to build the criteria from, not null.
     */
    public Criteria buildCriteria(Spedizione obj)
    {
        Criteria criteria = new Criteria(getDatabaseName());
        if (!obj.isNew())
        {
            criteria.and(SpedizionePeer.CODICE, obj.getCodice());
        }
        criteria.and(SpedizionePeer.PESO, obj.getPeso());
        criteria.and(SpedizionePeer.PREZZO, obj.getPrezzo());
        criteria.and(SpedizionePeer.EMAIL_MITTENTE, obj.getEmailMittente());
        criteria.and(SpedizionePeer.EMAIL_DESTINATARIO, obj.getEmailDestinatario());
        criteria.and(SpedizionePeer.IVA_CORRIERE, obj.getIvaCorriere());
        return criteria;
    }

    /** 
     * Build a Criteria object from the data object for this peer,
     * skipping all binary columns.
     *
     * @param obj the object to build the criteria from, not null.
     */
    public Criteria buildSelectCriteria(Spedizione obj)
    {
        Criteria criteria = new Criteria(getDatabaseName());
        if (!obj.isNew())
        {
            criteria.and(SpedizionePeer.CODICE, obj.getCodice());
        }
        criteria.and(SpedizionePeer.PESO, obj.getPeso());
        criteria.and(SpedizionePeer.PREZZO, obj.getPrezzo());
        criteria.and(SpedizionePeer.EMAIL_MITTENTE, obj.getEmailMittente());
        criteria.and(SpedizionePeer.EMAIL_DESTINATARIO, obj.getEmailDestinatario());
        criteria.and(SpedizionePeer.IVA_CORRIERE, obj.getIvaCorriere());
        return criteria;
    }

    /** 
     * Returns the contents of the object as ColumnValues object.
     * Primary key columns which are generated on insertion are not
     * added to the returned object if they still have their initial
     * value. Also, columns which have the useDatabaseDefaultValue
     * flag set to true are also not added to the returned object
     * if they still have their initial value.
     *
     * @throws TorqueException if the table map cannot be retrieved
     *         (should not happen).
     */
    public ColumnValues buildColumnValues(Spedizione spedizione)
            throws TorqueException
    {
        ColumnValues columnValues = new ColumnValues();
        if (!spedizione.isNew() 
            || spedizione.getCodice() != null)
        {
            columnValues.put(
                    SpedizionePeer.CODICE,
                    new JdbcTypedValue(
                        spedizione.getCodice(),
                        12));
        }
        columnValues.put(
                SpedizionePeer.PESO,
                new JdbcTypedValue(
                    spedizione.getPeso(),
                    4));
        columnValues.put(
                SpedizionePeer.PREZZO,
                new JdbcTypedValue(
                    spedizione.getPrezzo(),
                    4));
        columnValues.put(
                SpedizionePeer.EMAIL_MITTENTE,
                new JdbcTypedValue(
                    spedizione.getEmailMittente(),
                    12));
        columnValues.put(
                SpedizionePeer.EMAIL_DESTINATARIO,
                new JdbcTypedValue(
                    spedizione.getEmailDestinatario(),
                    12));
        columnValues.put(
                SpedizionePeer.IVA_CORRIERE,
                new JdbcTypedValue(
                    spedizione.getIvaCorriere(),
                    12));
        return columnValues;
    }

    /**
     * Retrieve a single object by pk
     *
     * @param pk the primary key
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     * @throws NoRowsException Primary key was not found in database.
     * @throws TooManyRowsException Primary key was not found in database.
     */
    public Spedizione retrieveByPK(String pk)
        throws TorqueException, NoRowsException, TooManyRowsException
    {
        return retrieveByPK(SimpleKey.keyFor(pk));
    }

    /**
     * Retrieve a single object by pk
     *
     * @param pk the primary key
     * @param con the connection to use
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     * @throws NoRowsException Primary key was not found in database.
     * @throws TooManyRowsException Primary key was not found in database.
     */
    public Spedizione retrieveByPK(String pk, Connection con)
        throws TorqueException, NoRowsException, TooManyRowsException
    {
        return retrieveByPK(SimpleKey.keyFor(pk), con);
    }
    
    
    

    /**
     * Retrieve a single object by pk
     *
     * @param pk the primary key
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     * @throws NoRowsException Primary key was not found in database.
     * @throws TooManyRowsException Primary key was not found in database.
     */
    public Spedizione retrieveByPK(ObjectKey<?> pk)
        throws TorqueException, NoRowsException, TooManyRowsException
    {
        try (TorqueConnection connection = Transaction.begin(getDatabaseName()))
        {
            Spedizione result = retrieveByPK(pk, connection);
            Transaction.commit(connection);
            return result;
        }
    }

    /**
     * Retrieve a single object by pk
     *
     * @param pk the primary key
     * @param con the connection to use
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     * @throws NoRowsException Primary key was not found in database.
     * @throws TooManyRowsException Primary key was not found in database.
     */
    public Spedizione retrieveByPK(ObjectKey<?> pk, Connection con)
        throws TorqueException, NoRowsException, TooManyRowsException
    {
        Criteria criteria = buildCriteria(pk);
        Spedizione v = doSelectSingleRecord(criteria, con);
        if (v == null)
        {
            throw new NoRowsException("Failed to select a row.");
        }

        return v;
    }


    /**
     * Retrieve multiple objects by pk.
     *
     * @param pks List of primary keys.
     *        Entries in pks which do not match entries in the database are ignored.
     *
     * @return the list of matching objects, not null.
     *
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     */
    public List<Spedizione> retrieveByTypedPKs(Collection<String> pks)
        throws TorqueException
    {
        try (TorqueConnection connection = Transaction.begin(getDatabaseName()))
        {
            List<Spedizione> result = retrieveByTypedPKs(pks, connection);
            Transaction.commit(connection);
            return result;
        }
    }

    /**
     * Retrieve multiple objects by pk.
     *
     * @param pks List of primary keys.
     *        Entries in pks which do not match entries in the database are ignored.
     * @param dbcon the connection to use
     *
     * @return the list of matching objects, not null.
     *
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     */
    public List<Spedizione> retrieveByTypedPKs(
                Collection<String> pks,
                Connection dbcon)
            throws TorqueException
    {
        if (pks == null || pks.size() == 0)
        {
            return new ArrayList<Spedizione>();
        }
        List<ObjectKey<?>> objectKeyList = new ArrayList<ObjectKey<?>>();
        for (String pk : pks)
        {
            objectKeyList.add(SimpleKey.keyFor(pk));
        }
        Criteria criteria = buildCriteria(objectKeyList);
        List<Spedizione> result = doSelect(criteria, dbcon);
        return result;
    }

    /**
     * Retrieve multiple objects by pk.
     *
     * @param pks List of primary keys.
     *        Entries in pks which do not match entries in the database are ignored.
     *
     * @return the list of matching objects, not null.
     *
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     */
    public List<Spedizione> retrieveByObjectKeys(Collection<ObjectKey<?>> pks)
        throws TorqueException
    {
        try (TorqueConnection connection = Transaction.begin(getDatabaseName()))
        {
            List<Spedizione> result = retrieveByObjectKeys(pks, connection);
            Transaction.commit(connection);
            return result;
        }
    }

    /**
     * Retrieve multiple objects by pk.
     *
     * @param pks List of primary keys.
     *        Entries in pks which do not match entries in the database are ignored.
     * @param dbcon the connection to use
     *
     * @return the list of matching objects, not null.
     *
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     */
    public List<Spedizione> retrieveByObjectKeys(
                Collection<ObjectKey<?>> pks,
                Connection dbcon)
            throws TorqueException
    {
        if (pks == null || pks.size() == 0)
        {
            return new ArrayList<Spedizione>();
        }
        Criteria criteria = buildCriteria(pks);
        List<Spedizione> result = doSelect(criteria, dbcon);
        return result;
    }


    /**
     * Selects a collection of dbObjectClassName objects pre-filled with their
     * Corriere objects.
     *
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     */
    public List<Spedizione> doSelectJoinCorriere(Criteria criteria)
        throws TorqueException
    {
        try (TorqueConnection connection = Transaction.begin(getDatabaseName()))
        {
            List<Spedizione> result
                    = SpedizionePeer.doSelectJoinCorriere(criteria, connection);
            Transaction.commit(connection);
            return result;
        }
    }

    /**
     * Selects a collection of Spedizione objects pre-filled with their
     * Corriere objects.
     *
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     */
    public List<Spedizione> doSelectJoinCorriere(
            Criteria criteria, Connection conn)
        throws TorqueException
    {
        setDbName(criteria);

        addSelectColumns(criteria);
        com.opcal.CorrierePeer.addSelectColumns(criteria);

        CompositeMapper compositeMapper = new CompositeMapper();
        compositeMapper.addMapper(
                new SpedizioneRecordMapper(),
                0);
        compositeMapper.addMapper(
                new CorriereRecordMapper(),
                SpedizionePeer.numColumns);
        criteria.addJoin(SpedizionePeer.IVA_CORRIERE,
            com.opcal.CorrierePeer.IVA);

        correctBooleans(criteria);

        List<Spedizione> result = new ArrayList<Spedizione>();
        List<List<Object>> rawResult = doSelect(
                criteria, compositeMapper, conn);
        for (List<Object> rawResultRow : rawResult)
        {
            Spedizione obj1 = (Spedizione) rawResultRow.get(0);
            Corriere obj2 = (Corriere) rawResultRow.get(1);

            boolean newObject = true;
            for (int j = 0; j < result.size(); j++)
            {
                Spedizione temp_obj1 = result.get(j);
                com.opcal.Corriere temp_obj2 = temp_obj1.getCorriere();
                if (temp_obj2.getPrimaryKey().equals(obj2.getPrimaryKey()))
                {
                    newObject = false;
                    temp_obj2.addSpedizione(obj1);
                    break;
                }
            }
            if (newObject)
            {
                obj2.initSpediziones();
                obj2.addSpedizione(obj1);
            }
            result.add(obj1);
        }
        return result;
    }
    /**
     * Selects a collection of dbObjectClassName objects pre-filled with their
     * Cliente objects.
     *
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     */
    public List<Spedizione> doSelectJoinClienteRelatedByEmailMittente(Criteria criteria)
        throws TorqueException
    {
        try (TorqueConnection connection = Transaction.begin(getDatabaseName()))
        {
            List<Spedizione> result
                    = SpedizionePeer.doSelectJoinClienteRelatedByEmailMittente(criteria, connection);
            Transaction.commit(connection);
            return result;
        }
    }

    /**
     * Selects a collection of Spedizione objects pre-filled with their
     * Cliente objects.
     *
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     */
    public List<Spedizione> doSelectJoinClienteRelatedByEmailMittente(
            Criteria criteria, Connection conn)
        throws TorqueException
    {
        setDbName(criteria);

        addSelectColumns(criteria);
        com.opcal.ClientePeer.addSelectColumns(criteria);

        CompositeMapper compositeMapper = new CompositeMapper();
        compositeMapper.addMapper(
                new SpedizioneRecordMapper(),
                0);
        compositeMapper.addMapper(
                new ClienteRecordMapper(),
                SpedizionePeer.numColumns);
        criteria.addJoin(SpedizionePeer.EMAIL_MITTENTE,
            com.opcal.ClientePeer.EMAIL);

        correctBooleans(criteria);

        List<Spedizione> result = new ArrayList<Spedizione>();
        List<List<Object>> rawResult = doSelect(
                criteria, compositeMapper, conn);
        for (List<Object> rawResultRow : rawResult)
        {
            Spedizione obj1 = (Spedizione) rawResultRow.get(0);
            Cliente obj2 = (Cliente) rawResultRow.get(1);

            boolean newObject = true;
            for (int j = 0; j < result.size(); j++)
            {
                Spedizione temp_obj1 = result.get(j);
                com.opcal.Cliente temp_obj2 = temp_obj1.getClienteRelatedByEmailMittente();
                if (temp_obj2.getPrimaryKey().equals(obj2.getPrimaryKey()))
                {
                    newObject = false;
                    temp_obj2.addSpedizioneRelatedByEmailMittente(obj1);
                    break;
                }
            }
            if (newObject)
            {
                obj2.initSpedizioneRelatedByEmailMittentes();
                obj2.addSpedizioneRelatedByEmailMittente(obj1);
            }
            result.add(obj1);
        }
        return result;
    }
    /**
     * Selects a collection of dbObjectClassName objects pre-filled with their
     * Cliente objects.
     *
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     */
    public List<Spedizione> doSelectJoinClienteRelatedByEmailDestinatario(Criteria criteria)
        throws TorqueException
    {
        try (TorqueConnection connection = Transaction.begin(getDatabaseName()))
        {
            List<Spedizione> result
                    = SpedizionePeer.doSelectJoinClienteRelatedByEmailDestinatario(criteria, connection);
            Transaction.commit(connection);
            return result;
        }
    }

    /**
     * Selects a collection of Spedizione objects pre-filled with their
     * Cliente objects.
     *
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     */
    public List<Spedizione> doSelectJoinClienteRelatedByEmailDestinatario(
            Criteria criteria, Connection conn)
        throws TorqueException
    {
        setDbName(criteria);

        addSelectColumns(criteria);
        com.opcal.ClientePeer.addSelectColumns(criteria);

        CompositeMapper compositeMapper = new CompositeMapper();
        compositeMapper.addMapper(
                new SpedizioneRecordMapper(),
                0);
        compositeMapper.addMapper(
                new ClienteRecordMapper(),
                SpedizionePeer.numColumns);
        criteria.addJoin(SpedizionePeer.EMAIL_DESTINATARIO,
            com.opcal.ClientePeer.EMAIL);

        correctBooleans(criteria);

        List<Spedizione> result = new ArrayList<Spedizione>();
        List<List<Object>> rawResult = doSelect(
                criteria, compositeMapper, conn);
        for (List<Object> rawResultRow : rawResult)
        {
            Spedizione obj1 = (Spedizione) rawResultRow.get(0);
            Cliente obj2 = (Cliente) rawResultRow.get(1);

            boolean newObject = true;
            for (int j = 0; j < result.size(); j++)
            {
                Spedizione temp_obj1 = result.get(j);
                com.opcal.Cliente temp_obj2 = temp_obj1.getClienteRelatedByEmailDestinatario();
                if (temp_obj2.getPrimaryKey().equals(obj2.getPrimaryKey()))
                {
                    newObject = false;
                    temp_obj2.addSpedizioneRelatedByEmailDestinatario(obj1);
                    break;
                }
            }
            if (newObject)
            {
                obj2.initSpedizioneRelatedByEmailDestinatarios();
                obj2.addSpedizioneRelatedByEmailDestinatario(obj1);
            }
            result.add(obj1);
        }
        return result;
    }

    /**
     * selects a collection of Spedizione objects pre-filled with
     * all related objects.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in SpedizionePeerImpl.
     *
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     */
    protected List<Spedizione> doSelectJoinAllExceptCorriere(Criteria criteria)
        throws TorqueException
    {
        try (TorqueConnection connection = Transaction.begin(getDatabaseName()))
        {
            List<Spedizione> result
                    = SpedizionePeer.doSelectJoinAllExceptCorriere(criteria, connection);
            Transaction.commit(connection);
            return result;
        }
    }

    /**
     * selects a collection of Spedizione objects pre-filled with
     * related objects.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in SpedizionePeerImpl.
     *
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     */
    protected List<Spedizione> doSelectJoinAllExceptCorriere(Criteria criteria, Connection conn)
        throws TorqueException
    {
        setDbName(criteria);

        CompositeMapper compositeMapper = new CompositeMapper();
        compositeMapper.addMapper(new SpedizioneRecordMapper(), 0);
        SpedizionePeer.addSelectColumns(criteria);
        int offset = SpedizionePeer.numColumns;
 
        com.opcal.ClientePeer.addSelectColumns(criteria);
        criteria.addJoin(SpedizionePeer.EMAIL_MITTENTE, com.opcal.ClientePeer.EMAIL);
        compositeMapper.addMapper(new ClienteRecordMapper(), offset);
        offset = offset + com.opcal.ClientePeer.numColumns;
 
        com.opcal.ClientePeer.addSelectColumns(criteria);
        criteria.addJoin(SpedizionePeer.EMAIL_DESTINATARIO, com.opcal.ClientePeer.EMAIL);
        compositeMapper.addMapper(new ClienteRecordMapper(), offset);
        offset = offset + com.opcal.ClientePeer.numColumns;

        correctBooleans(criteria);

        List<Spedizione> result = new ArrayList<Spedizione>();
        List<List<Object>> rawResult = doSelect(
                criteria, compositeMapper, conn);
        for (List<Object> rawResultRow : rawResult)
        {
            Spedizione spedizione = (Spedizione) rawResultRow.get(0);

            com.opcal.Cliente obj1 = (com.opcal.Cliente) rawResultRow.get(1);
            boolean newObject = true;
            for (int j = 0; j < result.size(); j++)
            {
                com.opcal.Spedizione temp_spedizione = result.get(j);
                com.opcal.Cliente temp_obj1 = temp_spedizione.getClienteRelatedByEmailMittente();
                if (temp_obj1.getPrimaryKey().equals(obj1.getPrimaryKey()))
                {
                    newObject = false;
                    temp_obj1.addSpedizioneRelatedByEmailMittente(spedizione);
                    break;
                }
            }
            if (newObject)
            {
                obj1.initSpedizioneRelatedByEmailMittentes();
                obj1.addSpedizioneRelatedByEmailMittente(spedizione);
            }

            com.opcal.Cliente obj2 = (com.opcal.Cliente) rawResultRow.get(2);
            newObject = true;
            for (int j = 0; j < result.size(); j++)
            {
                com.opcal.Spedizione temp_spedizione = result.get(j);
                com.opcal.Cliente temp_obj2 = temp_spedizione.getClienteRelatedByEmailDestinatario();
                if (temp_obj2.getPrimaryKey().equals(obj2.getPrimaryKey()))
                {
                    newObject = false;
                    temp_obj2.addSpedizioneRelatedByEmailDestinatario(spedizione);
                    break;
                }
            }
            if (newObject)
            {
                obj2.initSpedizioneRelatedByEmailDestinatarios();
                obj2.addSpedizioneRelatedByEmailDestinatario(spedizione);
            }
            result.add(spedizione);
        }
        return result;
    }
    /**
     * selects a collection of Spedizione objects pre-filled with
     * all related objects.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in SpedizionePeerImpl.
     *
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     */
    protected List<Spedizione> doSelectJoinAllExceptClienteRelatedByEmailMittente(Criteria criteria)
        throws TorqueException
    {
        try (TorqueConnection connection = Transaction.begin(getDatabaseName()))
        {
            List<Spedizione> result
                    = SpedizionePeer.doSelectJoinAllExceptClienteRelatedByEmailMittente(criteria, connection);
            Transaction.commit(connection);
            return result;
        }
    }

    /**
     * selects a collection of Spedizione objects pre-filled with
     * related objects.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in SpedizionePeerImpl.
     *
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     */
    protected List<Spedizione> doSelectJoinAllExceptClienteRelatedByEmailMittente(Criteria criteria, Connection conn)
        throws TorqueException
    {
        setDbName(criteria);

        CompositeMapper compositeMapper = new CompositeMapper();
        compositeMapper.addMapper(new SpedizioneRecordMapper(), 0);
        SpedizionePeer.addSelectColumns(criteria);
        int offset = SpedizionePeer.numColumns;
 
        com.opcal.CorrierePeer.addSelectColumns(criteria);
        criteria.addJoin(SpedizionePeer.IVA_CORRIERE, com.opcal.CorrierePeer.IVA);
        compositeMapper.addMapper(new CorriereRecordMapper(), offset);
        offset = offset + com.opcal.CorrierePeer.numColumns;
 
        com.opcal.ClientePeer.addSelectColumns(criteria);
        criteria.addJoin(SpedizionePeer.EMAIL_DESTINATARIO, com.opcal.ClientePeer.EMAIL);
        compositeMapper.addMapper(new ClienteRecordMapper(), offset);
        offset = offset + com.opcal.ClientePeer.numColumns;

        correctBooleans(criteria);

        List<Spedizione> result = new ArrayList<Spedizione>();
        List<List<Object>> rawResult = doSelect(
                criteria, compositeMapper, conn);
        for (List<Object> rawResultRow : rawResult)
        {
            Spedizione spedizione = (Spedizione) rawResultRow.get(0);

            com.opcal.Corriere obj1 = (com.opcal.Corriere) rawResultRow.get(1);
            boolean newObject = true;
            for (int j = 0; j < result.size(); j++)
            {
                com.opcal.Spedizione temp_spedizione = result.get(j);
                com.opcal.Corriere temp_obj1 = temp_spedizione.getCorriere();
                if (temp_obj1.getPrimaryKey().equals(obj1.getPrimaryKey()))
                {
                    newObject = false;
                    temp_obj1.addSpedizione(spedizione);
                    break;
                }
            }
            if (newObject)
            {
                obj1.initSpediziones();
                obj1.addSpedizione(spedizione);
            }

            com.opcal.Cliente obj2 = (com.opcal.Cliente) rawResultRow.get(2);
            newObject = true;
            for (int j = 0; j < result.size(); j++)
            {
                com.opcal.Spedizione temp_spedizione = result.get(j);
                com.opcal.Cliente temp_obj2 = temp_spedizione.getClienteRelatedByEmailDestinatario();
                if (temp_obj2.getPrimaryKey().equals(obj2.getPrimaryKey()))
                {
                    newObject = false;
                    temp_obj2.addSpedizioneRelatedByEmailDestinatario(spedizione);
                    break;
                }
            }
            if (newObject)
            {
                obj2.initSpedizioneRelatedByEmailDestinatarios();
                obj2.addSpedizioneRelatedByEmailDestinatario(spedizione);
            }
            result.add(spedizione);
        }
        return result;
    }
    /**
     * selects a collection of Spedizione objects pre-filled with
     * all related objects.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in SpedizionePeerImpl.
     *
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     */
    protected List<Spedizione> doSelectJoinAllExceptClienteRelatedByEmailDestinatario(Criteria criteria)
        throws TorqueException
    {
        try (TorqueConnection connection = Transaction.begin(getDatabaseName()))
        {
            List<Spedizione> result
                    = SpedizionePeer.doSelectJoinAllExceptClienteRelatedByEmailDestinatario(criteria, connection);
            Transaction.commit(connection);
            return result;
        }
    }

    /**
     * selects a collection of Spedizione objects pre-filled with
     * related objects.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in SpedizionePeerImpl.
     *
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     */
    protected List<Spedizione> doSelectJoinAllExceptClienteRelatedByEmailDestinatario(Criteria criteria, Connection conn)
        throws TorqueException
    {
        setDbName(criteria);

        CompositeMapper compositeMapper = new CompositeMapper();
        compositeMapper.addMapper(new SpedizioneRecordMapper(), 0);
        SpedizionePeer.addSelectColumns(criteria);
        int offset = SpedizionePeer.numColumns;
 
        com.opcal.CorrierePeer.addSelectColumns(criteria);
        criteria.addJoin(SpedizionePeer.IVA_CORRIERE, com.opcal.CorrierePeer.IVA);
        compositeMapper.addMapper(new CorriereRecordMapper(), offset);
        offset = offset + com.opcal.CorrierePeer.numColumns;
 
        com.opcal.ClientePeer.addSelectColumns(criteria);
        criteria.addJoin(SpedizionePeer.EMAIL_MITTENTE, com.opcal.ClientePeer.EMAIL);
        compositeMapper.addMapper(new ClienteRecordMapper(), offset);
        offset = offset + com.opcal.ClientePeer.numColumns;

        correctBooleans(criteria);

        List<Spedizione> result = new ArrayList<Spedizione>();
        List<List<Object>> rawResult = doSelect(
                criteria, compositeMapper, conn);
        for (List<Object> rawResultRow : rawResult)
        {
            Spedizione spedizione = (Spedizione) rawResultRow.get(0);

            com.opcal.Corriere obj1 = (com.opcal.Corriere) rawResultRow.get(1);
            boolean newObject = true;
            for (int j = 0; j < result.size(); j++)
            {
                com.opcal.Spedizione temp_spedizione = result.get(j);
                com.opcal.Corriere temp_obj1 = temp_spedizione.getCorriere();
                if (temp_obj1.getPrimaryKey().equals(obj1.getPrimaryKey()))
                {
                    newObject = false;
                    temp_obj1.addSpedizione(spedizione);
                    break;
                }
            }
            if (newObject)
            {
                obj1.initSpediziones();
                obj1.addSpedizione(spedizione);
            }

            com.opcal.Cliente obj2 = (com.opcal.Cliente) rawResultRow.get(2);
            newObject = true;
            for (int j = 0; j < result.size(); j++)
            {
                com.opcal.Spedizione temp_spedizione = result.get(j);
                com.opcal.Cliente temp_obj2 = temp_spedizione.getClienteRelatedByEmailMittente();
                if (temp_obj2.getPrimaryKey().equals(obj2.getPrimaryKey()))
                {
                    newObject = false;
                    temp_obj2.addSpedizioneRelatedByEmailMittente(spedizione);
                    break;
                }
            }
            if (newObject)
            {
                obj2.initSpedizioneRelatedByEmailMittentes();
                obj2.addSpedizioneRelatedByEmailMittente(spedizione);
            }
            result.add(spedizione);
        }
        return result;
    }

    /** 
     * Saves the passed collection as linked objects.
     * This means the following is done:
     * <ul>
     *  <li>
     *    The current collection of objects which are linked to toLinkTo
     *    and which are also in the list toSave is read from the database
     *    into the list intersection.
     *  </li>
     *  <li>
     *    All objects in toSave which are not in intersection are inserted.
     *  </li>
     *  <li>
     *    All objects in intersection are updated with the 
     *    corresponding values in toSave and saved.
     *  </li>
     *  <li>
     *    All objects in the database which are linked to toLinkTo but are 
     *    not in toSave are deleted from the database.
     *  </li>
     * </ul>
     *
     * @param toLinkTo the object which collections should be set with the
     *        values in toSave.
     * @param toSave Contains the objects to save, not null, 
     *        may not contain null.
     *
     * @throws TorqueException if an error accessing the database occurs.
     * @throws NullPointerException if toSave is null or contains null elements.
     */
    public void setAndSaveRicevutas(
            Spedizione toLinkTo,
            Collection<Ricevuta> toSave) 
        throws TorqueException
    {
        try (TorqueConnection connection = Transaction.begin(getDatabaseName()))
        {
            setAndSaveRicevutas(toLinkTo, toSave, connection);
            Transaction.commit(connection);
        }
    }

    /** 
     * Saves the passed collection as linked objects.
     * This means the following is done:
     * <ul>
     *  <li>
     *    The current collection of objects which are linked to toLinkTo
     *    and which are also in the list toSave is read from the database
     *    into the list intersection.
     *  </li>
     *  <li>
     *    All objects in toSave which are not in intersection are inserted.
     *  </li>
     *  <li>
     *    All objects in intersection are updated with the 
     *    corresponding values in toSave and saved.
     *  </li>
     *  <li>
     *    All objects in the database which are linked to toLinkTo but are 
     *    not in toSave are deleted from the database.
     *  </li>
     * </ul>
     *
     * @param toLinkTo the object which collections should be set with the
     *        values in toSave.
     * @param toSave Contains the objects to save, not null, 
     *        may not contain null.
     * @param connection the database connection to use.
     *
     * @throws TorqueException if an error accessing the database occurs.
     * @throws NullPointerException if toSave is null or contains null elements.
     */
    public void setAndSaveRicevutas(
            Spedizione toLinkTo,
            Collection<Ricevuta> toSave,
            Connection connection) 
        throws TorqueException
    {
        // make sure the collection cache in toLinkTo represents the current
        // database state
        toLinkTo.resetRicevuta();
        toLinkTo.getRicevutas(connection);
        ObjectKey<?> localKey = toLinkTo.getPrimaryKey();

        Criteria criteria = new Criteria();
        Criterion onlyReferencingCriterion = new Criterion(
                RicevutaPeer.CODICE, 
                localKey);
        criteria.where(onlyReferencingCriterion);
        Set<ObjectKey<?>> toSaveKeys = new HashSet<ObjectKey<?>>();
        for (Ricevuta toSaveElement : toSave)
        {
            ObjectKey<?> toSaveKey = toSaveElement.getPrimaryKey();
            if (toSaveKey.getValue() != null)
            {
                toSaveKeys.add(toSaveKey);
            }
        }
        
        // calculate intersection between objects in the database
        // and objects in the list
        List<Ricevuta> intersection;
        if (toSaveKeys.isEmpty())
        {
            intersection = new ArrayList<Ricevuta>();
        }
        else
        {
            criteria.and(
                    RicevutaPeer.CODICE,
                     toSaveKeys,
                      Criteria.IN);
            intersection = RicevutaPeer.doSelect(
                    criteria,
                    connection);
        }
        if (toLinkTo.isRicevutasInitialized())
        {
            toLinkTo.getRicevutas().clear();
        }
        else
        {
           toLinkTo.initRicevutas();
        }
        for (Ricevuta toSaveElement : toSave)
        {
            int listIndex = intersection.indexOf(toSaveElement);
            if (listIndex == -1)
            {
                toLinkTo.addRicevuta(toSaveElement);
                toSaveElement.save(connection);
            }
            else
            {
                toLinkTo.addRicevuta(toSaveElement);
                toSaveElement.setNew(false);
                if (!toSaveElement.valueEquals(intersection.get(listIndex)))
                {
                    //force saving if content differs
                    toSaveElement.setModified(true);
                }
                toSaveElement.save(connection);
            }
            toSaveKeys.add(toSaveElement.getPrimaryKey());
        }
        
        // delete elements not in intersection
        Criteria deleteCriteria = new Criteria();
        deleteCriteria.where(onlyReferencingCriterion);
        if (!toSaveKeys.isEmpty())
        {
            deleteCriteria.and(
                    RicevutaPeer.CODICE, 
                    toSaveKeys, 
                    Criteria.NOT_IN);
        }
        RicevutaPeer.doDelete(deleteCriteria, connection);
    }
    /** 
     * Saves the passed collection as linked objects.
     * This means the following is done:
     * <ul>
     *  <li>
     *    The current collection of objects which are linked to toLinkTo
     *    and which are also in the list toSave is read from the database
     *    into the list intersection.
     *  </li>
     *  <li>
     *    All objects in toSave which are not in intersection are inserted.
     *  </li>
     *  <li>
     *    All objects in intersection are updated with the 
     *    corresponding values in toSave and saved.
     *  </li>
     *  <li>
     *    All objects in the database which are linked to toLinkTo but are 
     *    not in toSave are deleted from the database.
     *  </li>
     * </ul>
     *
     * @param toLinkTo the object which collections should be set with the
     *        values in toSave.
     * @param toSave Contains the objects to save, not null, 
     *        may not contain null.
     *
     * @throws TorqueException if an error accessing the database occurs.
     * @throws NullPointerException if toSave is null or contains null elements.
     */
    public void setAndSavePrenotatas(
            Spedizione toLinkTo,
            Collection<Prenotata> toSave) 
        throws TorqueException
    {
        try (TorqueConnection connection = Transaction.begin(getDatabaseName()))
        {
            setAndSavePrenotatas(toLinkTo, toSave, connection);
            Transaction.commit(connection);
        }
    }

    /** 
     * Saves the passed collection as linked objects.
     * This means the following is done:
     * <ul>
     *  <li>
     *    The current collection of objects which are linked to toLinkTo
     *    and which are also in the list toSave is read from the database
     *    into the list intersection.
     *  </li>
     *  <li>
     *    All objects in toSave which are not in intersection are inserted.
     *  </li>
     *  <li>
     *    All objects in intersection are updated with the 
     *    corresponding values in toSave and saved.
     *  </li>
     *  <li>
     *    All objects in the database which are linked to toLinkTo but are 
     *    not in toSave are deleted from the database.
     *  </li>
     * </ul>
     *
     * @param toLinkTo the object which collections should be set with the
     *        values in toSave.
     * @param toSave Contains the objects to save, not null, 
     *        may not contain null.
     * @param connection the database connection to use.
     *
     * @throws TorqueException if an error accessing the database occurs.
     * @throws NullPointerException if toSave is null or contains null elements.
     */
    public void setAndSavePrenotatas(
            Spedizione toLinkTo,
            Collection<Prenotata> toSave,
            Connection connection) 
        throws TorqueException
    {
        // make sure the collection cache in toLinkTo represents the current
        // database state
        toLinkTo.resetPrenotata();
        toLinkTo.getPrenotatas(connection);
        ObjectKey<?> localKey = toLinkTo.getPrimaryKey();

        Criteria criteria = new Criteria();
        Criterion onlyReferencingCriterion = new Criterion(
                PrenotataPeer.CODICE, 
                localKey);
        criteria.where(onlyReferencingCriterion);
        Set<ObjectKey<?>> toSaveKeys = new HashSet<ObjectKey<?>>();
        for (Prenotata toSaveElement : toSave)
        {
            ObjectKey<?> toSaveKey = toSaveElement.getPrimaryKey();
            if (toSaveKey.getValue() != null)
            {
                toSaveKeys.add(toSaveKey);
            }
        }
        
        // calculate intersection between objects in the database
        // and objects in the list
        List<Prenotata> intersection;
        if (toSaveKeys.isEmpty())
        {
            intersection = new ArrayList<Prenotata>();
        }
        else
        {
            criteria.and(
                    PrenotataPeer.CODICE,
                     toSaveKeys,
                      Criteria.IN);
            intersection = PrenotataPeer.doSelect(
                    criteria,
                    connection);
        }
        if (toLinkTo.isPrenotatasInitialized())
        {
            toLinkTo.getPrenotatas().clear();
        }
        else
        {
           toLinkTo.initPrenotatas();
        }
        for (Prenotata toSaveElement : toSave)
        {
            int listIndex = intersection.indexOf(toSaveElement);
            if (listIndex == -1)
            {
                toLinkTo.addPrenotata(toSaveElement);
                toSaveElement.save(connection);
            }
            else
            {
                toLinkTo.addPrenotata(toSaveElement);
                toSaveElement.setNew(false);
                if (!toSaveElement.valueEquals(intersection.get(listIndex)))
                {
                    //force saving if content differs
                    toSaveElement.setModified(true);
                }
                toSaveElement.save(connection);
            }
            toSaveKeys.add(toSaveElement.getPrimaryKey());
        }
        
        // delete elements not in intersection
        Criteria deleteCriteria = new Criteria();
        deleteCriteria.where(onlyReferencingCriterion);
        if (!toSaveKeys.isEmpty())
        {
            deleteCriteria.and(
                    PrenotataPeer.CODICE, 
                    toSaveKeys, 
                    Criteria.NOT_IN);
        }
        PrenotataPeer.doDelete(deleteCriteria, connection);
    }
    /** 
     * Saves the passed collection as linked objects.
     * This means the following is done:
     * <ul>
     *  <li>
     *    The current collection of objects which are linked to toLinkTo
     *    and which are also in the list toSave is read from the database
     *    into the list intersection.
     *  </li>
     *  <li>
     *    All objects in toSave which are not in intersection are inserted.
     *  </li>
     *  <li>
     *    All objects in intersection are updated with the 
     *    corresponding values in toSave and saved.
     *  </li>
     *  <li>
     *    All objects in the database which are linked to toLinkTo but are 
     *    not in toSave are deleted from the database.
     *  </li>
     * </ul>
     *
     * @param toLinkTo the object which collections should be set with the
     *        values in toSave.
     * @param toSave Contains the objects to save, not null, 
     *        may not contain null.
     *
     * @throws TorqueException if an error accessing the database occurs.
     * @throws NullPointerException if toSave is null or contains null elements.
     */
    public void setAndSaveInCorsos(
            Spedizione toLinkTo,
            Collection<InCorso> toSave) 
        throws TorqueException
    {
        try (TorqueConnection connection = Transaction.begin(getDatabaseName()))
        {
            setAndSaveInCorsos(toLinkTo, toSave, connection);
            Transaction.commit(connection);
        }
    }

    /** 
     * Saves the passed collection as linked objects.
     * This means the following is done:
     * <ul>
     *  <li>
     *    The current collection of objects which are linked to toLinkTo
     *    and which are also in the list toSave is read from the database
     *    into the list intersection.
     *  </li>
     *  <li>
     *    All objects in toSave which are not in intersection are inserted.
     *  </li>
     *  <li>
     *    All objects in intersection are updated with the 
     *    corresponding values in toSave and saved.
     *  </li>
     *  <li>
     *    All objects in the database which are linked to toLinkTo but are 
     *    not in toSave are deleted from the database.
     *  </li>
     * </ul>
     *
     * @param toLinkTo the object which collections should be set with the
     *        values in toSave.
     * @param toSave Contains the objects to save, not null, 
     *        may not contain null.
     * @param connection the database connection to use.
     *
     * @throws TorqueException if an error accessing the database occurs.
     * @throws NullPointerException if toSave is null or contains null elements.
     */
    public void setAndSaveInCorsos(
            Spedizione toLinkTo,
            Collection<InCorso> toSave,
            Connection connection) 
        throws TorqueException
    {
        // make sure the collection cache in toLinkTo represents the current
        // database state
        toLinkTo.resetInCorso();
        toLinkTo.getInCorsos(connection);
        ObjectKey<?> localKey = toLinkTo.getPrimaryKey();

        Criteria criteria = new Criteria();
        Criterion onlyReferencingCriterion = new Criterion(
                InCorsoPeer.CODICE, 
                localKey);
        criteria.where(onlyReferencingCriterion);
        Set<ObjectKey<?>> toSaveKeys = new HashSet<ObjectKey<?>>();
        for (InCorso toSaveElement : toSave)
        {
            ObjectKey<?> toSaveKey = toSaveElement.getPrimaryKey();
            if (toSaveKey.getValue() != null)
            {
                toSaveKeys.add(toSaveKey);
            }
        }
        
        // calculate intersection between objects in the database
        // and objects in the list
        List<InCorso> intersection;
        if (toSaveKeys.isEmpty())
        {
            intersection = new ArrayList<InCorso>();
        }
        else
        {
            criteria.and(
                    InCorsoPeer.CODICE,
                     toSaveKeys,
                      Criteria.IN);
            intersection = InCorsoPeer.doSelect(
                    criteria,
                    connection);
        }
        if (toLinkTo.isInCorsosInitialized())
        {
            toLinkTo.getInCorsos().clear();
        }
        else
        {
           toLinkTo.initInCorsos();
        }
        for (InCorso toSaveElement : toSave)
        {
            int listIndex = intersection.indexOf(toSaveElement);
            if (listIndex == -1)
            {
                toLinkTo.addInCorso(toSaveElement);
                toSaveElement.save(connection);
            }
            else
            {
                toLinkTo.addInCorso(toSaveElement);
                toSaveElement.setNew(false);
                if (!toSaveElement.valueEquals(intersection.get(listIndex)))
                {
                    //force saving if content differs
                    toSaveElement.setModified(true);
                }
                toSaveElement.save(connection);
            }
            toSaveKeys.add(toSaveElement.getPrimaryKey());
        }
        
        // delete elements not in intersection
        Criteria deleteCriteria = new Criteria();
        deleteCriteria.where(onlyReferencingCriterion);
        if (!toSaveKeys.isEmpty())
        {
            deleteCriteria.and(
                    InCorsoPeer.CODICE, 
                    toSaveKeys, 
                    Criteria.NOT_IN);
        }
        InCorsoPeer.doDelete(deleteCriteria, connection);
    }
    /** 
     * Saves the passed collection as linked objects.
     * This means the following is done:
     * <ul>
     *  <li>
     *    The current collection of objects which are linked to toLinkTo
     *    and which are also in the list toSave is read from the database
     *    into the list intersection.
     *  </li>
     *  <li>
     *    All objects in toSave which are not in intersection are inserted.
     *  </li>
     *  <li>
     *    All objects in intersection are updated with the 
     *    corresponding values in toSave and saved.
     *  </li>
     *  <li>
     *    All objects in the database which are linked to toLinkTo but are 
     *    not in toSave are deleted from the database.
     *  </li>
     * </ul>
     *
     * @param toLinkTo the object which collections should be set with the
     *        values in toSave.
     * @param toSave Contains the objects to save, not null, 
     *        may not contain null.
     *
     * @throws TorqueException if an error accessing the database occurs.
     * @throws NullPointerException if toSave is null or contains null elements.
     */
    public void setAndSaveEffettuatas(
            Spedizione toLinkTo,
            Collection<Effettuata> toSave) 
        throws TorqueException
    {
        try (TorqueConnection connection = Transaction.begin(getDatabaseName()))
        {
            setAndSaveEffettuatas(toLinkTo, toSave, connection);
            Transaction.commit(connection);
        }
    }

    /** 
     * Saves the passed collection as linked objects.
     * This means the following is done:
     * <ul>
     *  <li>
     *    The current collection of objects which are linked to toLinkTo
     *    and which are also in the list toSave is read from the database
     *    into the list intersection.
     *  </li>
     *  <li>
     *    All objects in toSave which are not in intersection are inserted.
     *  </li>
     *  <li>
     *    All objects in intersection are updated with the 
     *    corresponding values in toSave and saved.
     *  </li>
     *  <li>
     *    All objects in the database which are linked to toLinkTo but are 
     *    not in toSave are deleted from the database.
     *  </li>
     * </ul>
     *
     * @param toLinkTo the object which collections should be set with the
     *        values in toSave.
     * @param toSave Contains the objects to save, not null, 
     *        may not contain null.
     * @param connection the database connection to use.
     *
     * @throws TorqueException if an error accessing the database occurs.
     * @throws NullPointerException if toSave is null or contains null elements.
     */
    public void setAndSaveEffettuatas(
            Spedizione toLinkTo,
            Collection<Effettuata> toSave,
            Connection connection) 
        throws TorqueException
    {
        // make sure the collection cache in toLinkTo represents the current
        // database state
        toLinkTo.resetEffettuata();
        toLinkTo.getEffettuatas(connection);
        ObjectKey<?> localKey = toLinkTo.getPrimaryKey();

        Criteria criteria = new Criteria();
        Criterion onlyReferencingCriterion = new Criterion(
                EffettuataPeer.CODICE, 
                localKey);
        criteria.where(onlyReferencingCriterion);
        Set<ObjectKey<?>> toSaveKeys = new HashSet<ObjectKey<?>>();
        for (Effettuata toSaveElement : toSave)
        {
            ObjectKey<?> toSaveKey = toSaveElement.getPrimaryKey();
            if (toSaveKey.getValue() != null)
            {
                toSaveKeys.add(toSaveKey);
            }
        }
        
        // calculate intersection between objects in the database
        // and objects in the list
        List<Effettuata> intersection;
        if (toSaveKeys.isEmpty())
        {
            intersection = new ArrayList<Effettuata>();
        }
        else
        {
            criteria.and(
                    EffettuataPeer.CODICE,
                     toSaveKeys,
                      Criteria.IN);
            intersection = EffettuataPeer.doSelect(
                    criteria,
                    connection);
        }
        if (toLinkTo.isEffettuatasInitialized())
        {
            toLinkTo.getEffettuatas().clear();
        }
        else
        {
           toLinkTo.initEffettuatas();
        }
        for (Effettuata toSaveElement : toSave)
        {
            int listIndex = intersection.indexOf(toSaveElement);
            if (listIndex == -1)
            {
                toLinkTo.addEffettuata(toSaveElement);
                toSaveElement.save(connection);
            }
            else
            {
                toLinkTo.addEffettuata(toSaveElement);
                toSaveElement.setNew(false);
                if (!toSaveElement.valueEquals(intersection.get(listIndex)))
                {
                    //force saving if content differs
                    toSaveElement.setModified(true);
                }
                toSaveElement.save(connection);
            }
            toSaveKeys.add(toSaveElement.getPrimaryKey());
        }
        
        // delete elements not in intersection
        Criteria deleteCriteria = new Criteria();
        deleteCriteria.where(onlyReferencingCriterion);
        if (!toSaveKeys.isEmpty())
        {
            deleteCriteria.and(
                    EffettuataPeer.CODICE, 
                    toSaveKeys, 
                    Criteria.NOT_IN);
        }
        EffettuataPeer.doDelete(deleteCriteria, connection);
    }
    /** 
     * Saves the passed collection as linked objects.
     * This means the following is done:
     * <ul>
     *  <li>
     *    The current collection of objects which are linked to toLinkTo
     *    and which are also in the list toSave is read from the database
     *    into the list intersection.
     *  </li>
     *  <li>
     *    All objects in toSave which are not in intersection are inserted.
     *  </li>
     *  <li>
     *    All objects in intersection are updated with the 
     *    corresponding values in toSave and saved.
     *  </li>
     *  <li>
     *    All objects in the database which are linked to toLinkTo but are 
     *    not in toSave are deleted from the database.
     *  </li>
     * </ul>
     *
     * @param toLinkTo the object which collections should be set with the
     *        values in toSave.
     * @param toSave Contains the objects to save, not null, 
     *        may not contain null.
     *
     * @throws TorqueException if an error accessing the database occurs.
     * @throws NullPointerException if toSave is null or contains null elements.
     */
    public void setAndSaveResos(
            Spedizione toLinkTo,
            Collection<Reso> toSave) 
        throws TorqueException
    {
        try (TorqueConnection connection = Transaction.begin(getDatabaseName()))
        {
            setAndSaveResos(toLinkTo, toSave, connection);
            Transaction.commit(connection);
        }
    }

    /** 
     * Saves the passed collection as linked objects.
     * This means the following is done:
     * <ul>
     *  <li>
     *    The current collection of objects which are linked to toLinkTo
     *    and which are also in the list toSave is read from the database
     *    into the list intersection.
     *  </li>
     *  <li>
     *    All objects in toSave which are not in intersection are inserted.
     *  </li>
     *  <li>
     *    All objects in intersection are updated with the 
     *    corresponding values in toSave and saved.
     *  </li>
     *  <li>
     *    All objects in the database which are linked to toLinkTo but are 
     *    not in toSave are deleted from the database.
     *  </li>
     * </ul>
     *
     * @param toLinkTo the object which collections should be set with the
     *        values in toSave.
     * @param toSave Contains the objects to save, not null, 
     *        may not contain null.
     * @param connection the database connection to use.
     *
     * @throws TorqueException if an error accessing the database occurs.
     * @throws NullPointerException if toSave is null or contains null elements.
     */
    public void setAndSaveResos(
            Spedizione toLinkTo,
            Collection<Reso> toSave,
            Connection connection) 
        throws TorqueException
    {
        // make sure the collection cache in toLinkTo represents the current
        // database state
        toLinkTo.resetReso();
        toLinkTo.getResos(connection);
        ObjectKey<?> localKey = toLinkTo.getPrimaryKey();

        Criteria criteria = new Criteria();
        Criterion onlyReferencingCriterion = new Criterion(
                ResoPeer.CODICE, 
                localKey);
        criteria.where(onlyReferencingCriterion);
        Set<ObjectKey<?>> toSaveKeys = new HashSet<ObjectKey<?>>();
        for (Reso toSaveElement : toSave)
        {
            ObjectKey<?> toSaveKey = toSaveElement.getPrimaryKey();
            if (toSaveKey.getValue() != null)
            {
                toSaveKeys.add(toSaveKey);
            }
        }
        
        // calculate intersection between objects in the database
        // and objects in the list
        List<Reso> intersection;
        if (toSaveKeys.isEmpty())
        {
            intersection = new ArrayList<Reso>();
        }
        else
        {
            criteria.and(
                    ResoPeer.CODICE,
                     toSaveKeys,
                      Criteria.IN);
            intersection = ResoPeer.doSelect(
                    criteria,
                    connection);
        }
        if (toLinkTo.isResosInitialized())
        {
            toLinkTo.getResos().clear();
        }
        else
        {
           toLinkTo.initResos();
        }
        for (Reso toSaveElement : toSave)
        {
            int listIndex = intersection.indexOf(toSaveElement);
            if (listIndex == -1)
            {
                toLinkTo.addReso(toSaveElement);
                toSaveElement.save(connection);
            }
            else
            {
                toLinkTo.addReso(toSaveElement);
                toSaveElement.setNew(false);
                if (!toSaveElement.valueEquals(intersection.get(listIndex)))
                {
                    //force saving if content differs
                    toSaveElement.setModified(true);
                }
                toSaveElement.save(connection);
            }
            toSaveKeys.add(toSaveElement.getPrimaryKey());
        }
        
        // delete elements not in intersection
        Criteria deleteCriteria = new Criteria();
        deleteCriteria.where(onlyReferencingCriterion);
        if (!toSaveKeys.isEmpty())
        {
            deleteCriteria.and(
                    ResoPeer.CODICE, 
                    toSaveKeys, 
                    Criteria.NOT_IN);
        }
        ResoPeer.doDelete(deleteCriteria, connection);
    }


}
