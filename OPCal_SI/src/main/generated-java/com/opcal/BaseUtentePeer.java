package com.opcal;

import java.sql.Connection;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.stream.Stream;

import org.apache.torque.NoRowsException;
import org.apache.torque.TooManyRowsException;
import org.apache.torque.Column;
import org.apache.torque.Torque;
import org.apache.torque.TorqueException;
import org.apache.torque.adapter.IDMethod;
import org.apache.torque.criteria.Criteria;
import org.apache.torque.map.DatabaseMap;
import org.apache.torque.map.TableMap;
import org.apache.torque.map.ColumnMap;
import org.apache.torque.om.mapper.RecordMapper;
import org.apache.torque.om.ObjectKey;
import org.apache.torque.util.ColumnValues;
import org.apache.torque.util.JdbcTypedValue;



/**
 * The skeleton for this class was autogenerated by Torque on:
 *
 * [Thu Mar 13 14:45:22 CET 2025]
 *
 * You should not use this class directly.  It should not even be
 * extended; all references should be to UtentePeer
 */

@SuppressWarnings("unused")
public abstract class BaseUtentePeer
{
    /** The default database name for this class. */
    public static final String DATABASE_NAME;

     /** The table name for this class. */
    public static final String TABLE_NAME;

     /** The table map for this class. */
    public static final TableMap TABLE;
    /** The column for the email field */
    public static final ColumnMap EMAIL;
    /** The column for the nome field */
    public static final ColumnMap NOME;
    /** The column for the password field */
    public static final ColumnMap PASSWORD;
    /** The column for the cognome field */
    public static final ColumnMap COGNOME;

    /** number of columns for this peer */
    public static final int numColumns = 4;


    /** The implementation of the peer. */
    private static UtentePeerImpl utentePeerImpl;


    static
    {
        DatabaseMap dbMap = Torque.getOrCreateDatabase("opcal")
                .getDatabaseMap();
        if (dbMap.getTable("utente") == null)
        {
            dbMap.addTable("utente");
        }
        DATABASE_NAME = "opcal";
        TABLE_NAME = "utente";

        TABLE = dbMap.getTable("utente");
        TABLE.setJavaName("Utente");
        TABLE.setOMClass(com.opcal.Utente.class);
        TABLE.setPeerClass(com.opcal.UtentePeer.class);
        TABLE.setPrimaryKeyMethod(IDMethod.NATIVE);
        TABLE.setPrimaryKeyMethodInfo(IDMethod.ID_BROKER, TABLE.getName());
        TABLE.setPrimaryKeyMethodInfo(IDMethod.SEQUENCE, "utente_SEQ");
        TABLE.setPrimaryKeyMethodInfo(IDMethod.AUTO_INCREMENT, "utente");
        TABLE.setUseInheritance(true);


    // ------------- Column: email --------------------
        EMAIL = new ColumnMap("email", TABLE);
        EMAIL.setType("");
        EMAIL.setTorqueType("VARCHAR");
        EMAIL.setUsePrimitive(false);
        EMAIL.setPrimaryKey(true);
        EMAIL.setNotNull(true);
        EMAIL.setJavaName("Email");
        EMAIL.setAutoIncrement(true);
        EMAIL.setProtected(false);
        EMAIL.setJavaType( "String" );
        EMAIL.setDescription("Email utente");
        EMAIL.setSize(255);
        EMAIL.setPosition(1);
        TABLE.addColumn(EMAIL);
    // ------------- Column: nome --------------------
        NOME = new ColumnMap("nome", TABLE);
        NOME.setType("");
        NOME.setTorqueType("VARCHAR");
        NOME.setUsePrimitive(false);
        NOME.setPrimaryKey(false);
        NOME.setNotNull(true);
        NOME.setJavaName("Nome");
        NOME.setAutoIncrement(true);
        NOME.setProtected(false);
        NOME.setJavaType( "String" );
        NOME.setDescription("Nome utente");
        NOME.setSize(255);
        NOME.setPosition(2);
        TABLE.addColumn(NOME);
    // ------------- Column: password --------------------
        PASSWORD = new ColumnMap("password", TABLE);
        PASSWORD.setType("");
        PASSWORD.setTorqueType("VARCHAR");
        PASSWORD.setUsePrimitive(false);
        PASSWORD.setPrimaryKey(false);
        PASSWORD.setNotNull(true);
        PASSWORD.setJavaName("Password");
        PASSWORD.setAutoIncrement(true);
        PASSWORD.setProtected(false);
        PASSWORD.setJavaType( "String" );
        PASSWORD.setDescription("password utente");
        PASSWORD.setSize(255);
        PASSWORD.setPosition(3);
        TABLE.addColumn(PASSWORD);
    // ------------- Column: cognome --------------------
        COGNOME = new ColumnMap("cognome", TABLE);
        COGNOME.setType("");
        COGNOME.setTorqueType("VARCHAR");
        COGNOME.setUsePrimitive(false);
        COGNOME.setPrimaryKey(false);
        COGNOME.setNotNull(true);
        COGNOME.setJavaName("Cognome");
        COGNOME.setAutoIncrement(true);
        COGNOME.setProtected(false);
        COGNOME.setJavaType( "String" );
        COGNOME.setDescription("Cognome utente");
        COGNOME.setSize(255);
        COGNOME.setPosition(4);
        TABLE.addColumn(COGNOME);



        initDatabaseMap();
    }

    /**
     * Creates a new instance of the  implementation of the peer.
     *
     * @return the new instance.
     */
    protected static UtentePeerImpl createUtentePeerImpl()
    {
        UtentePeerImpl instance = new UtentePeerImpl();
        return instance;
    }


    /**
     * Returns an instance of the implementation of the peer.
     * If no instance is currently cached, a new instance is created and cached.
     *
     * @return an instance of the implementation of the peer, not null.
     */
    public static UtentePeerImpl getUtentePeerImpl()
    {
        UtentePeerImpl peerImplInstance = utentePeerImpl;
        if (peerImplInstance == null)
        {
            peerImplInstance = UtentePeer.createUtentePeerImpl();
            utentePeerImpl = peerImplInstance;
            Torque.registerPeerInstance(Utente.class, peerImplInstance);
        }
        return peerImplInstance;
    }



    /**
     * Sets the instance of the implementation of the peer.
     *
     * @param peerImplInstance an instance of the implementation of the peer, or null
     *        if a new instance should be created automatically.
     */
    public static void setUtentePeerImpl(UtentePeerImpl peerImplInstance)
    {
        utentePeerImpl = peerImplInstance;
    }


    /**
     * Add all the columns needed to create a new object.
     *
     * @param criteria object containing the columns to add.
     */
    public static void addSelectColumns(Criteria criteria)
    {
        getUtentePeerImpl().addSelectColumns(criteria);
    }

    /**
     * changes the boolean values in the criteria to the appropriate type,
     * whenever a booleanchar or booleanint column is involved.
     * This enables the user to create criteria using Boolean values
     * for booleanchar or booleanint columns.
     *
     * @param criteria the criteria in which the boolean values
     *        should be corrected.
     *
     * @throws TorqueException if the database map for the criteria cannot be 
               obtained.
     */
    public static void correctBooleans(Criteria criteria) throws TorqueException
    {
        getUtentePeerImpl().correctBooleans(criteria);
    }

    /**
     * Checks all columns in the criteria to see whether
     * booleanchar and booleanint columns are queried with a boolean.
     * If yes, the query values are mapped onto values the database
     * does understand, i.e. 0 and 1 for booleanints and N and Y for
     * booleanchar columns.
     *
     * @param columnValues The value to be checked for booleanint
     *        and booleanchar columns.
     * @throws TorqueException if the database map for the criteria cannot be
     *         retrieved.
     */
    public static void correctBooleans(
            ColumnValues columnValues)
        throws TorqueException
    {
        getUtentePeerImpl().correctBooleans(columnValues);
    }
    
    /**
     * Selects Utente objects from a database.
     *
     * @param criteria object used to create the SELECT statement.
     *
     * @return the list of selected objects, not null.
     *
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     */
    public static List<Utente> doSelect(Criteria criteria)
            throws TorqueException
    {
        return getUtentePeerImpl().doSelect(criteria);
    }

    /**
     * Selects Utente objects from a database
     * within a transaction.
     *
     * @param criteria object used to create the SELECT statement.
     * @param connection the connection holding the transaction, not null.
     *
     * @return The list of selected objects, not null.
     *
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     */
    public static List<Utente> doSelect(
                Criteria criteria,
                Connection connection)
            throws TorqueException
    {
        return getUtentePeerImpl().doSelect(criteria, connection);
    }

    /**
     * Selects Utente objects from a database
     * within a transaction.
     *
     * This method returns a stream that <b>must</b> be closed after use.
     * All resources used by this method will be closed when the stream is
     * closed.
     *
     * @param criteria object used to create the SELECT statement.
     * @param connection the connection holding the transaction, not null.
     *
     * @return The results of the query as a Stream, not null.
     *
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     */
    public static Stream<Utente> doSelectAsStream(
                Criteria criteria,
                Connection connection)
            throws TorqueException
    {
        return getUtentePeerImpl().doSelectAsStream(criteria, connection);
    }

    /**
     * Selects rows from a database an maps them to objects.
     *
     * @param criteria A Criteria specifying the records to select, not null.
     * @param mapper The mapper creating the objects from the resultSet,
     *        not null.
     *
     * @return The results of the query, not null.
     *
     * @throws TorqueException if querying the database fails.
     */
    public static <T> List<T> doSelect(
                Criteria criteria,
                RecordMapper<T> mapper)
            throws TorqueException
    {
        return getUtentePeerImpl().doSelect(criteria, mapper);
    }

    /**
     * Selects rows from a database an maps them to objects.
     *
     * @param criteria A Criteria specifying the records to select, not null.
     * @param mapper The mapper creating the objects from the resultSet,
     *        not null.
     * @param connection the database connection for selecting records,
     *        not null.
     *
     * @return The results of the query, not null.
     *
     * @throws TorqueException Error performing database query.
     */
    public static <T> List<T> doSelect(
            Criteria criteria,
            RecordMapper<T> mapper,
            Connection connection)
        throws TorqueException
    {
        return getUtentePeerImpl().doSelect(
                criteria,
                mapper,
                connection);
    }

    /**
     * Selects rows from a database an maps them to objects.
     *
     * This method returns a stream that <b>must</b> be closed after use.
     * All resources used by this method will be closed when the stream is
     * closed.
     *
     * @param criteria A Criteria specifying the records to select, not null.
     * @param mapper The mapper creating the objects from the resultSet,
     *        not null.
     * @param connection the database connection for selecting records,
     *        not null.
     *
     * @return The results of the query as a Stream, not null.
     *
     * @throws TorqueException Error performing database query.
     */
    public static <T> Stream<T> doSelectAsStream(
            Criteria criteria,
            RecordMapper<T> mapper,
            Connection connection)
        throws TorqueException
    {
        return getUtentePeerImpl().doSelectAsStream(
                criteria,
                mapper,
                connection);
    }

    /**
     * Selects rows from a database an maps them to objects.
     *
     * @param query the sql query to execute, not null.
     * @param mapper The mapper creating the objects from the resultSet,
     *        not null.
     * @param dbName The name of the database to create the connection for,
     *        or null for the default SDB.
     *
     * @return The results of the query, not null.
     *
     * @throws TorqueException if querying the database fails.
     */
    public static <T> List<T> doSelect(
                String query,
                RecordMapper<T> mapper,
                String dbName)
            throws TorqueException
    {
        return getUtentePeerImpl().doSelect(
                query,
                mapper,
                dbName);
    }

    /**
     * Selects rows from a database an maps them to objects.
     *
     * @param query the SQL Query to execute, not null.
     * @param mapper The mapper creating the objects from the resultSet,
     *        not null.
     * @param connection the database connection, not null.
     *
     * @return The results of the query, not null.
     *
     * @throws TorqueException if querying the database fails.
     */
    public static <T> List<T> doSelect(
                String query,
                RecordMapper<T> mapper,
                Connection connection)
            throws TorqueException
    {
        return getUtentePeerImpl().doSelect(
                query,
                mapper,
                connection);
    }

    /**
     * Selects rows from a database an maps them to objects.
     *
     * This method returns a stream that <b>must</b> be closed after use.
     * All resources used by this method will be closed when the stream is
     * closed.
     *
     * @param query the SQL Query to execute, not null.
     * @param mapper The mapper creating the objects from the resultSet,
     *        not null.
     * @param connection the database connection, not null.
     *
     * @return The results of the query as a Stream, not null.
     *
     * @throws TorqueException if querying the database fails.
     */
    public static <T> Stream<T> doSelectAsStream(
                String query,
                RecordMapper<T> mapper,
                Connection connection)
            throws TorqueException
    {
        return getUtentePeerImpl().doSelectAsStream(
                query,
                mapper,
                connection);
    }

    /**
     * Selects Utente objects from the database which have
     * the same content as the passed object.
     *
     * @return The list of selected objects, not null.
     *
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     */
    public static List<Utente> doSelect(Utente obj)
            throws TorqueException
    {
        return getUtentePeerImpl().doSelect(obj);
    }

    /**
     * Selects at most one Utente object from a database.
     *
     * @param criteria object used to create the SELECT statement.
     *
     * @return the selected Object, or null if no object was selected.
     *
     * @throws TorqueException If more than one record is selected or if
     *         an error occurs when processing the query.
     */
    public static Utente doSelectSingleRecord(
                Criteria criteria)
            throws TorqueException
    {
        return getUtentePeerImpl().doSelectSingleRecord(criteria);
    }

    /**
     * Selects at most one Utente object from a database
     * within a transaction.
     *
     * @param criteria object used to create the SELECT statement.
     * @param connection the connection holding the transaction, not null.
     *
     * @return the selected Object, or null if no object was selected.
     *
     * @throws TorqueException If more than one record is selected or if
     *         an error occurs when processing the query.
     */
    public static Utente doSelectSingleRecord(
                Criteria criteria,
                Connection connection)
            throws TorqueException
    {
        return getUtentePeerImpl().doSelectSingleRecord(criteria, connection);
    }

    /**
     * Selects at most a single row from a database an maps them to objects.
     *
     * @param criteria A Criteria specifying the records to select, not null.
     * @param mapper The mapper creating the objects from the resultSet,
     *        not null.
     *
     * @return The selected row, or null if no records was selected.
     *
     * @throws TorqueException if querying the database fails.
     */
    public static <T> T doSelectSingleRecord(
                org.apache.torque.criteria.Criteria criteria,
                RecordMapper<T> mapper)
            throws TorqueException
    {
        return getUtentePeerImpl().doSelectSingleRecord(
                criteria,
                mapper);
    }

    /**
     * Selects at most a single row from a database an maps them to objects.
     *
     * @param criteria A Criteria specifying the records to select, not null.
     * @param mapper The mapper creating the objects from the resultSet,
     *        not null.
     * @param connection the database connection, not null.
     *
     * @return The selected row, or null if no records was selected.
     *
     * @throws TorqueException if querying the database fails.
     */
    public static <T> T doSelectSingleRecord(
                org.apache.torque.criteria.Criteria criteria,
                RecordMapper<T> mapper,
                Connection connection)
            throws TorqueException
    {
        return getUtentePeerImpl().doSelectSingleRecord(
                criteria,
                mapper,
                connection);
    }

    /**
     * Selects at most one Utente object from the database
     * which has the same content as the passed object.
     *
     * @return the selected Object, or null if no object was selected.
     *
     * @throws TorqueException If more than one record is selected or if
     *         an error occurs when processing the query.
     */
    public static Utente doSelectSingleRecord(
                Utente obj)
            throws TorqueException
    {
        return getUtentePeerImpl().doSelectSingleRecord(obj);
    }


    /**
     * Returns a new instance of the Data object class
     */
    public static Utente getDbObjectInstance()
    {
        return getUtentePeerImpl().getDbObjectInstance();
    }


    /**
     * Method to do inserts.
     *
     * @param columnValues the values to insert.
     *
     * @return the primary key of the inserted row.
     *
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     */
    public static ObjectKey<?> doInsert(ColumnValues columnValues) 
            throws TorqueException
    {
        return getUtentePeerImpl().doInsert(columnValues);
    }

    /**
     * Method to do inserts.  This method is to be used during a transaction,
     * otherwise use the doInsert(Criteria) method.
     *
     * @param columnValues the values to insert.
     * @param con the connection to use, not null.
     *
     * @return the primary key of the inserted row.
     *
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     */
    public static ObjectKey<?> doInsert(ColumnValues columnValues, Connection con)
            throws TorqueException
    {
        return getUtentePeerImpl().doInsert(columnValues, con);
    }
    /**
     * Method to do inserts
     *
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     */
    public static void doInsert(Utente obj)
            throws TorqueException
    {
        getUtentePeerImpl().doInsert(obj);
    }

    /**
     * Method to do inserts.  This method is to be used during a transaction,
     * otherwise use the doInsert(Utente) method.  It will take
     * care of the connection details internally.
     *
     * @param obj the data object to insert into the database.
     * @param con the connection to use
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     */
    public static void doInsert(Utente obj, Connection con)
            throws TorqueException
    {
        getUtentePeerImpl().doInsert(obj, con);
    }

    /**
     * Executes a insert into...select statement.
     *
     * @param toInsertInto the columns in which to insert, not null.
     * @param criteria the criteria which selects the values to insert,
     *        not null.
     *
     * @return the number of inserted rows.
     *
     * @throws TorqueException if a database error occurs.
     */
    public static int doInsert(
                final Column[] toInsertInto,
                final Criteria criteria)
            throws TorqueException
    {
        return getUtentePeerImpl().doInsert(toInsertInto, criteria);
    }

    /**
     * Executes a insert into...select statement.
     *
     * @param toInsertInto the columns in which to insert, not null.
     * @param criteria the criteria which selects the values to insert,
     *        not null.
     * @param dbName the database name, or null to take the database name
     *        from getDatabaseName().
     *
     * @return the number of inserted rows.
     *
     * @throws TorqueException if a database error occurs.
     */
    public static int doInsert(
                final Column[] toInsertInto,
                final Criteria criteria,
                final String dbName)
            throws TorqueException
    {
        return getUtentePeerImpl().doInsert(toInsertInto, criteria, dbName);
    }

    /**
     * Executes a insert into...select statement.
     *
     * @param toInsertInto the columns in which to insert, not null.
     * @param criteria the criteria which selects the values to insert,
     *        not null.
     * @param connection the database connection to use, not null.
     *
     * @return the number of inserted rows.
     *
     * @throws TorqueException if a database error occurs.
     */
    public static int doInsert(
                final Column[] toInsertInto,
                final Criteria criteria,
                final Connection connection)
            throws TorqueException
    {
        return getUtentePeerImpl().doInsert(toInsertInto, criteria, connection);
    }

    /**
     * Executes a insert into...select statement.
     *
     * @param toInsertInto the columns in which to insert, not null.
     * @param criteria the criteria which selects the values to insert,
     *        not null.
     * @param dbName the database name, or null to take the database name
     *        from getDatabaseName().
     * @param connection the database connection to use, not null.
     *
     * @return the number of inserted rows.
     *
     * @throws TorqueException if a database error occurs.
     */
    public static int doInsert(
                final Column[] toInsertInto,
                final Criteria criteria,
                String dbName,
                final Connection connection)
            throws TorqueException
    {
        return getUtentePeerImpl().doInsert(
                 toInsertInto,
                 criteria,
                 dbName,
                 connection);
    }

    /**
     * Method to do updates.
     *
     * @param columnValues the values to update plus the primary key
     *        identifying the row to update.
     *
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     */
    public static int doUpdate(ColumnValues columnValues) throws TorqueException
    {
        return getUtentePeerImpl().doUpdate(columnValues);
    }

    /**
     * Method to do updates.  This method is to be used during a transaction,
     * otherwise use the doUpdate(Criteria) method.  It will take care of
     * the connection details internally.
     *
     * @param columnValues the values to update plus the primary key
     *        identifying the row to update.
     * @param con the connection to use, not null.
     *
     * @return the number of affected rows.
     *
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     */
    public static int doUpdate(ColumnValues columnValues, Connection con)
        throws TorqueException
    {
        return getUtentePeerImpl().doUpdate(columnValues, con);
    }

    /**
     * Executes an update against the database. The rows to be updated
     * are selected using <code>criteria</code> and updated using the values
     * in <code>updateValues</code>.
     *
     * @param selectCriteria selects which rows of which table should be updated.
     * @param updateValues Which columns to update with which values, not null.
     *
     * @return the number of affected rows.
     *
     * @throws TorqueException if updating fails.
     */
    public static int doUpdate(
                Criteria selectCriteria,
                ColumnValues updateValues)
            throws TorqueException
    {
        return getUtentePeerImpl().doUpdate(
            selectCriteria,
            updateValues);
    }

    /**
     * Executes an update against the database. The rows to be updated
     * are selected using <code>criteria</code> and updated using the values
     * in <code>updateValues</code>.
     *
     * @param criteria selects which rows of which table should be updated.
     * @param updateValues Which columns to update with which values, not null.
     * @param connection the database connection to use, not null.
     *
     * @return the number of affected rows.
     *
     * @throws TorqueException if updating fails.
     */
    public static int doUpdate(
                Criteria criteria,
                ColumnValues updateValues,
                Connection connection)
            throws TorqueException
    {
        return getUtentePeerImpl().doUpdate(
            criteria,
             updateValues,
              connection);
    }

    /**
     * Updates an Utente in the database.
     * The primary key is used to identify the object to update.
     *
     * @param obj the data object to update in the database.
     *
     * @return the number of affected rows.
     *
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     */
    public static int doUpdate(Utente obj) throws TorqueException
    {
        return getUtentePeerImpl().doUpdate(obj);
    }

    /**
     * Updates a Utente in the database.
     * The primary key is used to identify the object to update.
     * This method is to be used during a transaction,
     * otherwise the doUpdate(Utente) method can be used.
     *
     * @param obj the data object to update in the database.
     * @param con the connection to use, not null.
     
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     */
    public static int doUpdate(Utente obj, Connection con)
        throws TorqueException
    {
        return getUtentePeerImpl().doUpdate(obj, con);
    }

    /**
     * Utility method which executes a given sql statement
     * as prepared statement.
     * This method should be used for update, insert, and delete statements.
     * Use executeQuery() for selects.
     *
     * @param statementString A String with the sql statement to execute.
     *
     * @return The number of rows affected.
     *
     * @throws TorqueException if executing the statement fails
     *         or no database connection can be established.
     */
    public static int executeStatement(String statementString) 
            throws TorqueException
    {
        return getUtentePeerImpl().executeStatement(statementString);
    }

    /**
     * Utility method which executes a given sql statement
     * as prepared statement.
     * This method should be used for update, insert, and delete statements.
     * Use executeQuery() for selects.
     *
     * @param statementString A String with the sql statement to execute.
     * @param replacementValues values to use as placeholders in the query.
     *        or null or empty if no placeholders need to be filled.
     *
     * @return The number of rows affected.
     *
     * @throws TorqueException if executing the statement fails
     *         or no database connection can be established.
     */
    public static int executeStatement(
                String statementString,
                List<JdbcTypedValue> replacementValues)
            throws TorqueException
    {
        return getUtentePeerImpl().executeStatement(
                statementString, 
                replacementValues);
    }

    /**
     * Utility method which executes a given sql statement
     * as prepared statement.
     * This method should be used for update, insert, and delete statements.
     * Use executeQuery() for selects.
     *
     * @param statementString A String with the sql statement to execute.
     * @param dbName The name of the database to execute the statement against,
     *        or null for the default DB.
     * @param replacementValues values to use as placeholders in the query.
     *        or null or empty if no placeholders need to be filled.
     *
     * @return The number of rows affected.
     *
     * @throws TorqueException if executing the statement fails
     *         or no database connection can be established.
     */
    public static int executeStatement(
            String statementString,
            String dbName,
            List<JdbcTypedValue> replacementValues)
        throws TorqueException
    {
        return getUtentePeerImpl().executeStatement(
                statementString, 
                dbName,
                replacementValues);
    }

    /**
     * Utility method which executes a given sql statement
     * as prepared statement.
     * This method should be used for update, insert, and delete statements.
     * Use executeQuery() for selects.
     *
     * @param statementString A String with the sql statement to execute.
     * @param con The database connection to use.
     * @param replacementValues values to use as placeholders in the query.
     *        or null or empty if no placeholders need to be filled.
     *
     * @return The number of rows affected.
     *
     * @throws TorqueException if executing the statement fails.
     */
    public static int executeStatement(
            String statementString,
            Connection con,
            List<JdbcTypedValue> replacementValues)
        throws TorqueException
    {
        return getUtentePeerImpl().executeStatement(
                statementString, 
                con,
                replacementValues);
    }

    /**
     * Utility method which executes a given sql statement
     * as prepared statement.
     * This method should be used for update, insert, and delete statements.
     * Use executeQuery() for selects.
     *
     * @param statementString A String with the sql statement to execute,
     *        containing placeholders of the form ":${placeholderName}".
     *        ${placeholderName} must contain only letters, digits and the underscore
     *        Each placeholder must be followed by a space, except when it is at the end of the statement.
     * @param replacementValues a map mapping the placeholder names to values
     *        to use as placeholders in the query.
     *        Can be null or empty if no placeholders need to be filled.
     *
     * @return The number of rows affected.
     *
     * @throws TorqueException if executing the statement fails.
     */
    public static int executeStatement(
            final String statementString,
            final Map<String, JdbcTypedValue> replacementValues)
        throws TorqueException
    {
        return getUtentePeerImpl().executeStatement(
                statementString,
                replacementValues);
    }

    /**
     * Utility method which executes a given sql statement
     * as prepared statement.
     * This method should be used for update, insert, and delete statements.
     * Use executeQuery() for selects.
     *
     * @param statementString A String with the sql statement to execute,
     *        containing placeholders of the form ":${placeholderName}".
     *        ${placeholderName} must contain only letters, digits and the underscore
     *        Each placeholder must be followed by a space, except when it is at the end of the statement.
     * @param dbName The name of the database to execute the statement against,
     *        or null for the default DB.
     * @param replacementValues a map mapping the placeholder names to values
     *        to use as placeholders in the query.
     *        Can be null or empty if no placeholders need to be filled.
     *
     * @return The number of rows affected.
     *
     * @throws TorqueException if executing the statement fails.
     */
    public static int executeStatement(
                final String statementString,
                final String dbName,
                final Map<String, JdbcTypedValue> replacementValues)
            throws TorqueException
        {
        return getUtentePeerImpl().executeStatement(
                statementString,
                dbName,
                replacementValues);
        }

        /**
     * Utility method which executes a given sql statement
     * as prepared statement.
     * This method should be used for update, insert, and delete statements.
     * Use executeQuery() for selects.
     *
     * @param statementString A String with the sql statement to execute,
     *        containing placeholders of the form ":${placeholderName}".
     *        ${placeholderName} must contain only letters, digits and the underscore
     *        Each placeholder must be followed by a space, except when it is at the end of the statement.
     * @param con The database connection to use.
     * @param replacementValues a map mapping the placeholder names (without leading colons)
     *        to values to use as placeholders in the query.
     *        Can be null or empty if no placeholders need to be filled.
     *
     * @return The number of rows affected.
     *
     * @throws TorqueException if executing the statement fails.
     */
    public static int executeStatement(
                final String statementString,
                final Connection con,
                final Map<String, JdbcTypedValue> replacementValues)
            throws TorqueException
    {
        return getUtentePeerImpl().executeStatement(
                statementString,
                con,
                replacementValues);
    }

    
    /**
     * Deletes rows from a database table.
     *
     * @param criteria defines the rows to be deleted, not null.
     *
     * @return the number of deleted rows.
     *
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     */
     public static int doDelete(Criteria criteria) throws TorqueException
     {
        return getUtentePeerImpl().doDelete(criteria);
     }

    /**
     * Deletes rows from a table.
     * This method uses the passed connection to delete the rows;
     * if a transaction is open in the connection, the deletion happens inside
     * this transaction.
    *
     * @param criteria defines the rows to be deleted, not null.
     * @param con the connection to use, not null.
     *
     * @return the number of deleted rows.
     *
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     */
     public static int doDelete(Criteria criteria, Connection con)
        throws TorqueException
     {
        return getUtentePeerImpl().doDelete(criteria, con);
     }

    /**
     * Deletes a data object, i.e. a row in a table, in the database.
     *
     * @param obj the data object to delete in the database, not null.
     *
     * @return the number of deleted rows.
     *
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     */
    public static int doDelete(Utente obj) throws TorqueException
    {
        return getUtentePeerImpl().doDelete(obj);
    }

    /**
     * Deletes a data object, i.e. a row in a table, in the database.
     * This method uses the passed connection to delete the rows;
     * if a transaction is open in the connection, the deletion happens inside
     * this transaction.
     *
     * @param obj the data object to delete in the database, not null.
     * @param con the connection to use, not null.
     *
     * @return the number of deleted rows.
     *
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     */
    public static int doDelete(Utente obj, Connection con)
        throws TorqueException
    {
        return getUtentePeerImpl().doDelete(obj, con);
    }

    /**
     * Deletes data objects, i.e. rows in a table, in the database.
     *
     * @param objects the datas object to delete in the database, not null,
     *        may not contain null.
     *
     * @return the number of deleted rows.
     *
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     */
    public static int doDelete(Collection<Utente> objects)
            throws TorqueException
    {
        return getUtentePeerImpl().doDelete(objects);
    }

    /**
     * Deletes data objects, i.e. rows in a table, in the database.
     * This method uses the passed connection to delete the rows;
     * if a transaction is open in the connection, the deletion happens inside
     * this transaction.
     *
     * @param objects the datas object to delete in the database, not null,
     *        may not contain null.
     * @param con the connection to use for deleting, not null.
     *
     * @return the number of deleted rows.
     *
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     */
    public static int doDelete(
            Collection<Utente> objects,
            Connection con)
        throws TorqueException
    {
        return getUtentePeerImpl().doDelete(objects, con);
    }

    /**
     * Deletes a row in the database.
     *
     * @param pk the ObjectKey that identifies the row to delete.
     *
     * @return the number of deleted rows.
     *
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     */
    public static int doDelete(ObjectKey<?> pk) throws TorqueException
    {
        return getUtentePeerImpl().doDelete(pk);
    }

    /**
     * Deletes a row in the database.
     * This method uses the passed connection to delete the rows;
     * if a transaction is open in the connection, the deletion happens inside
     * this transaction.
     *
     * @param pk the ObjectKey that identifies the row to delete.
     * @param con the connection to use for deleting, not null.
     *
     * @return the number of deleted rows.
     *
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     */
    public static int doDelete(ObjectKey<?> pk, Connection con)
        throws TorqueException
    {
        return getUtentePeerImpl().doDelete(pk, con);
    }

    /** 
     * Build a Criteria object which selects all objects which have a given
     * primary key.
     *
     * @param pk the primary key value to build the criteria from, not null.
     */
    public static Criteria buildCriteria(ObjectKey<?> pk)
    {
        return getUtentePeerImpl().buildCriteria(pk);
    }

    /** 
     * Build a Criteria object which selects all objects which primary keys
     * are contained in the passed collection.
     *
     * @param pks the primary key values to build the criteria from, not null,
     *        may not contain null.
     */
    public static Criteria buildCriteria(Collection<ObjectKey<?>> pks)
    {
        return getUtentePeerImpl().buildCriteria(pks);
    }

    /** 
     * Build a Criteria object which selects all passed objects using their
     * primary key. Objects which do not yet have a primary key are ignored.
     *
     * @param objects the objects to build the criteria from, not null,
     *        may not contain null.
     */
    public static Criteria buildPkCriteria(
            Collection<Utente> objects)
    {
        return getUtentePeerImpl().buildPkCriteria(objects);
    }

    /** 
     * Build a Criteria object from the data object for this peer.
     *
     * @param obj the object to build the criteria from, not null.
     */
    public static Criteria buildCriteria(Utente obj)
    {
        return getUtentePeerImpl().buildCriteria(obj);
    }

    /** 
     * Build a Criteria object from the data object for this peer,
     * skipping all binary columns.
     *
     * @param obj the object to build the criteria from, not null.
     */
    public static Criteria buildSelectCriteria(Utente obj)
    {
        return getUtentePeerImpl().buildSelectCriteria(obj);
    }

    /** 
     * Returns the contents of the object as ColumnValues object
     *
     * @throws TorqueException if the table map cannot be retrieved
     *         (should not happen).
     */
    public static ColumnValues buildColumnValues(Utente utente)
            throws TorqueException
    {
        
        return getUtentePeerImpl().buildColumnValues(utente);
    }

    /**
     * Retrieve a single object by pk
     *
     * @param pk the primary key
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     * @throws NoRowsException Primary key was not found in database.
     * @throws TooManyRowsException Primary key was not found in database.
     */
    public static Utente retrieveByPK(String pk)
        throws TorqueException, NoRowsException, TooManyRowsException
    {
        return getUtentePeerImpl().retrieveByPK(pk);
    }

    /**
     * Retrieve a single object by pk
     *
     * @param pk the primary key
     * @param con the connection to use
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     * @throws NoRowsException Primary key was not found in database.
     * @throws TooManyRowsException Primary key was not found in database.
     */
    public static Utente retrieveByPK(String pk, Connection con)
        throws TorqueException, NoRowsException, TooManyRowsException
    {
        return getUtentePeerImpl().retrieveByPK(pk, con);
    }
    
    
    

    /**
     * Retrieve a single object by pk
     *
     * @param pk the primary key
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     * @throws NoRowsException Primary key was not found in database.
     * @throws TooManyRowsException Primary key was not found in database.
     */
    public static Utente retrieveByPK(ObjectKey<?> pk)
        throws TorqueException, NoRowsException, TooManyRowsException
    {
        return getUtentePeerImpl().retrieveByPK(pk);
    }

    /**
     * Retrieve a single object by pk
     *
     * @param pk the primary key
     * @param con the connection to use
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     * @throws NoRowsException Primary key was not found in database.
     * @throws TooManyRowsException Primary key was not found in database.
     */
    public static Utente retrieveByPK(ObjectKey<?> pk, Connection con)
        throws TorqueException, NoRowsException, TooManyRowsException
    {
        return getUtentePeerImpl().retrieveByPK(pk, con);
    }


    /**
     * Retrieve multiple objects by pk.
     *
     * @param pks List of primary keys
     *
     * @return the list of matching objects, not null.
     *
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     */
    public static List<Utente> retrieveByTypedPKs(Collection<String> pks)
        throws TorqueException
    {
        return getUtentePeerImpl().retrieveByTypedPKs(pks);
    }

    /**
     * Retrieve multiple objects by pk.
     *
     * @param pks List of primary keys
     * @param dbcon the connection to use
     *
     * @return the list of matching objects, not null.
     *
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     */
    public static List<Utente> retrieveByTypedPKs(
                Collection<String> pks,
                Connection dbcon)
            throws TorqueException
    {
        return getUtentePeerImpl().retrieveByTypedPKs(pks, dbcon);
    }

    /**
     * Retrieve a multiple objects by pk.
     *
     * @param pks List of primary keys
     *
     * @return the list of matching objects, not null.
     *
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     */
    public static List<Utente> retrieveByObjectKeys(Collection<ObjectKey<?>> pks)
        throws TorqueException
    {
        return getUtentePeerImpl().retrieveByObjectKeys(pks);
    }

    /**
     * Retrieve multiple objects by pk.
     *
     * @param pks List of primary keys
     * @param con the connection to use
     *
     * @return the list of matching objects, not null.
     *
     * @throws TorqueException Any exceptions caught during processing will be
     *         rethrown wrapped into a TorqueException.
     */
    public static List<Utente> retrieveByObjectKeys(Collection<ObjectKey<?>> pks, Connection con)
        throws TorqueException
    {
        return getUtentePeerImpl().retrieveByObjectKeys(pks, con);
    }




    /** 
     * Saves the passed collection as linked objects.
     * This means the following is done:
     * <ul>
     *  <li>
     *    The current collection of objects which are linked to toLinkTo
     *    and which are also in the list toSave is read from the database
     *    into the list intersection.
     *  </li>
     *  <li>
     *    All objects in toSave which are not in intersection are inserted.
     *  </li>
     *  <li>
     *    All objects in intersection are updated with the 
     *    corresponding values in toSave and saved.
     *  </li>
     *  <li>
     *    All objects in the database which are linked to toLinkTo but are 
     *    not in toSave are deleted from the database.
     *  </li>
     * </ul>
     *
     * @param toLinkTo the object which collections should be set with the
     *        values in toSave.
     * @param toSave Contains the objects to save, not null, 
     *        may not contain null.
     *
     * @throws TorqueException if an error accessing the database occurs.
     * @throws NullPointerException if toSave is null or contains null elements.
     */
    public static void setAndSaveClientes(
            Utente toLinkTo,
            Collection<Cliente> toSave) 
        throws TorqueException
    {
        getUtentePeerImpl().setAndSaveClientes(toLinkTo, toSave);
    }

    /** 
     * Saves the passed collection as linked objects.
     * This means the following is done:
     * <ul>
     *  <li>
     *    The current collection of objects which are linked to toLinkTo
     *    and which are also in the list toSave is read from the database
     *    into the list intersection.
     *  </li>
     *  <li>
     *    All objects in toSave which are not in intersection are inserted.
     *  </li>
     *  <li>
     *    All objects in intersection are updated with the 
     *    corresponding values in toSave and saved.
     *  </li>
     *  <li>
     *    All objects in the database which are linked to toLinkTo but are 
     *    not in toSave are deleted from the database.
     *  </li>
     * </ul>
     *
     * @param toLinkTo the object which collections should be set with the
     *        values in toSave.
     * @param toSave Contains the objects to save, not null, 
     *        may not contain null.
     * @param connection the database connection to use.
     *
     * @throws TorqueException if an error accessing the database occurs.
     * @throws NullPointerException if toSave is null or contains null elements.
     */
    public void setAndSaveClientes(
            Utente toLinkTo,
            Collection<Cliente> toSave,
            Connection connection) 
        throws TorqueException
    {
        getUtentePeerImpl().setAndSaveClientes(toLinkTo, toSave);
    }
    /** 
     * Saves the passed collection as linked objects.
     * This means the following is done:
     * <ul>
     *  <li>
     *    The current collection of objects which are linked to toLinkTo
     *    and which are also in the list toSave is read from the database
     *    into the list intersection.
     *  </li>
     *  <li>
     *    All objects in toSave which are not in intersection are inserted.
     *  </li>
     *  <li>
     *    All objects in intersection are updated with the 
     *    corresponding values in toSave and saved.
     *  </li>
     *  <li>
     *    All objects in the database which are linked to toLinkTo but are 
     *    not in toSave are deleted from the database.
     *  </li>
     * </ul>
     *
     * @param toLinkTo the object which collections should be set with the
     *        values in toSave.
     * @param toSave Contains the objects to save, not null, 
     *        may not contain null.
     *
     * @throws TorqueException if an error accessing the database occurs.
     * @throws NullPointerException if toSave is null or contains null elements.
     */
    public static void setAndSaveAmministratores(
            Utente toLinkTo,
            Collection<Amministratore> toSave) 
        throws TorqueException
    {
        getUtentePeerImpl().setAndSaveAmministratores(toLinkTo, toSave);
    }

    /** 
     * Saves the passed collection as linked objects.
     * This means the following is done:
     * <ul>
     *  <li>
     *    The current collection of objects which are linked to toLinkTo
     *    and which are also in the list toSave is read from the database
     *    into the list intersection.
     *  </li>
     *  <li>
     *    All objects in toSave which are not in intersection are inserted.
     *  </li>
     *  <li>
     *    All objects in intersection are updated with the 
     *    corresponding values in toSave and saved.
     *  </li>
     *  <li>
     *    All objects in the database which are linked to toLinkTo but are 
     *    not in toSave are deleted from the database.
     *  </li>
     * </ul>
     *
     * @param toLinkTo the object which collections should be set with the
     *        values in toSave.
     * @param toSave Contains the objects to save, not null, 
     *        may not contain null.
     * @param connection the database connection to use.
     *
     * @throws TorqueException if an error accessing the database occurs.
     * @throws NullPointerException if toSave is null or contains null elements.
     */
    public void setAndSaveAmministratores(
            Utente toLinkTo,
            Collection<Amministratore> toSave,
            Connection connection) 
        throws TorqueException
    {
        getUtentePeerImpl().setAndSaveAmministratores(toLinkTo, toSave);
    }
    /** 
     * Saves the passed collection as linked objects.
     * This means the following is done:
     * <ul>
     *  <li>
     *    The current collection of objects which are linked to toLinkTo
     *    and which are also in the list toSave is read from the database
     *    into the list intersection.
     *  </li>
     *  <li>
     *    All objects in toSave which are not in intersection are inserted.
     *  </li>
     *  <li>
     *    All objects in intersection are updated with the 
     *    corresponding values in toSave and saved.
     *  </li>
     *  <li>
     *    All objects in the database which are linked to toLinkTo but are 
     *    not in toSave are deleted from the database.
     *  </li>
     * </ul>
     *
     * @param toLinkTo the object which collections should be set with the
     *        values in toSave.
     * @param toSave Contains the objects to save, not null, 
     *        may not contain null.
     *
     * @throws TorqueException if an error accessing the database occurs.
     * @throws NullPointerException if toSave is null or contains null elements.
     */
    public static void setAndSaveDipendentes(
            Utente toLinkTo,
            Collection<Dipendente> toSave) 
        throws TorqueException
    {
        getUtentePeerImpl().setAndSaveDipendentes(toLinkTo, toSave);
    }

    /** 
     * Saves the passed collection as linked objects.
     * This means the following is done:
     * <ul>
     *  <li>
     *    The current collection of objects which are linked to toLinkTo
     *    and which are also in the list toSave is read from the database
     *    into the list intersection.
     *  </li>
     *  <li>
     *    All objects in toSave which are not in intersection are inserted.
     *  </li>
     *  <li>
     *    All objects in intersection are updated with the 
     *    corresponding values in toSave and saved.
     *  </li>
     *  <li>
     *    All objects in the database which are linked to toLinkTo but are 
     *    not in toSave are deleted from the database.
     *  </li>
     * </ul>
     *
     * @param toLinkTo the object which collections should be set with the
     *        values in toSave.
     * @param toSave Contains the objects to save, not null, 
     *        may not contain null.
     * @param connection the database connection to use.
     *
     * @throws TorqueException if an error accessing the database occurs.
     * @throws NullPointerException if toSave is null or contains null elements.
     */
    public void setAndSaveDipendentes(
            Utente toLinkTo,
            Collection<Dipendente> toSave,
            Connection connection) 
        throws TorqueException
    {
        getUtentePeerImpl().setAndSaveDipendentes(toLinkTo, toSave);
    }

    /**
     * Returns the TableMap related to this peer.
     *
     * @return the table map, not null.
     *
     * @throws TorqueException if the Peer instance does not hold a Table map.
     */
    public static TableMap getTableMap()
        throws TorqueException
    {
        return getUtentePeerImpl().getTableMap();
    }

    public static void initDatabaseMap()
    {
    }


}
